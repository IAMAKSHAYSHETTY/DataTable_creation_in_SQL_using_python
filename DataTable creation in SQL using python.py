# -*- coding: utf-8 -*-
"""Assignment3_group (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13bsavzNUyxOA1zVBSuC-Vh2BW32HSAg4
"""

import requests, json
import pandas as pd
import sqlalchemy as sa
from sqlalchemy import create_engine, types
from datetime import datetime, timedelta

curr_dt = datetime.now()
curr_dt = curr_dt.date()
hist_dt = datetime.today() - timedelta(days=3)
hist_dt = hist_dt.date()
print(curr_dt, hist_dt)

def dest_data(origin, dest):
    d_data = {}
    final_dest_data = pd.DataFrame()
    api_url1 = "https://maps.googleapis.com/maps/api/distancematrix/json?origins={}&destinations={}&units=imperial&key=AIzaSyC2AkC_u1591QUbwjM7mj8_p8T5IUOvh-w".format(origin,dest)
    payload={}
    headers = {}

    response = requests.request("GET", api_url1, headers=headers, data=payload)

    response = response.json()
    org_add = response['origin_addresses'][0]
    dest_add = response['destination_addresses'][0]
    dist_km = response['rows'][0]['elements'][0]['distance']['value'] / 1000
    dist_m = response['rows'][0]['elements'][0]['distance']['text']
    dur = response['rows'][0]['elements'][0]['duration']['text']
    return ([org_add, dest_add, dist_km, dist_m, dur])

cities = ['Toronto', 'Pickering', 'Ottawa', 'Brampton', 'Oshawa']
cols = ['org_add','dest_add', 'dist_km', 'dist_m', 'dur']
tot_dist_data = pd.DataFrame()
k=0
for i in range(0,len(cities)):
    for j in range(0,len(cities)):
        if(i!=j):
            dist_data = dest_data(cities[i], cities[j])
            dist_data = pd.DataFrame(dist_data)
            dist_data = dist_data.T
            tot_dist_data = tot_dist_data.append(dist_data)

tot_dist_data.columns = ['org_loc','dest_loc','dist_km', 'dist_m', 'dur']
tot_dist_data

#Historical Weather Data API
def hist_weather(city):
    api_url2_c1 = "https://weatherapi-com.p.rapidapi.com/history.json"
    #Make Changes to date and location
    querystring2_c1 = {"q":"{}".format(city),"dt":"{}".format(hist_dt),"lang":"en","end_dt":"{}".format(curr_dt)}
    headers2_c1 = {
        "X-RapidAPI-Key": "30c41bf000msh8b6ebc545ca1cacp1218e7jsn93c176b684be",
        "X-RapidAPI-Host": "weatherapi-com.p.rapidapi.com"
        }

    response2_c1 = requests.request("GET", api_url2_c1, headers=headers2_c1, params=querystring2_c1)
    response2_c1 = response2_c1.json()

    data1 = pd.DataFrame(response2_c1['forecast']['forecastday'][0]['hour'])
    data2 = pd.DataFrame(response2_c1['forecast']['forecastday'][1]['hour'])
    data3 = pd.DataFrame(response2_c1['forecast']['forecastday'][2]['hour'])
    data_c1 = [data1, data2, data3]
    data_c1 = pd.concat(data_c1, ignore_index=True, sort=False)
    for i in range(0,72):
        data_c1['condition'][i] = data_c1['condition'][i]['text']

    data_c1['loc_name'] = response2_c1['location']['name'] + ", " + response2_c1['location']['region'] + ", " + response2_c1['location']['country']
    data_c1['loc_lat'] = response2_c1['location']['lat']
    data_c1['loc_long'] = response2_c1['location']['lon']
    req_cols = ['loc_name','loc_lat','loc_long','time','temp_c','humidity','condition']
    city1 = data_c1[req_cols]
    return city1

city = ['Toronto', 'Pickering', 'Ottawa', 'Brampton', 'Oshawa']
hist_weather_data = pd.DataFrame()
#for i in range(0,len(city)):
dist_data = hist_weather(city[0])
dist_data1 = pd.DataFrame(dist_data)
dist_data = hist_weather(city[1])
dist_data2 = pd.DataFrame(dist_data)
dist_data = hist_weather(city[2])
dist_data3 = pd.DataFrame(dist_data)
dist_data = hist_weather(city[3])
dist_data4 = pd.DataFrame(dist_data)
dist_data = hist_weather(city[4])
dist_data5 = pd.DataFrame(dist_data)
#dist_data = dist_data.T
dist_data = [dist_data1, dist_data2, dist_data3, dist_data4, dist_data5]
hist_weather_data = pd.concat(dist_data, ignore_index=True)

hist_weather_data

#Weather Forecast Data API
api_url3_c1 = "https://weatherapi-com.p.rapidapi.com/forecast.json"
def fore_weather(city):
#Make Changes to location
    querystring3_c1 = {"q":"{}".format(city),"days":"3"}

    headers3_c1 = {
        "X-RapidAPI-Key": "30c41bf000msh8b6ebc545ca1cacp1218e7jsn93c176b684be",
        "X-RapidAPI-Host": "weatherapi-com.p.rapidapi.com"
    }

    response3_c1 = requests.request("GET", api_url3_c1, headers=headers3_c1, params=querystring3_c1)

    response3_c1 = response3_c1.json()
    data1 = pd.DataFrame(response3_c1['forecast']['forecastday'][0]['hour'])
    data2 = pd.DataFrame(response3_c1['forecast']['forecastday'][1]['hour'])
    data3 = pd.DataFrame(response3_c1['forecast']['forecastday'][2]['hour'])
    data = [data1, data2, data3]
    data = pd.concat(data, ignore_index=True, sort=False)

    for i in range(0,72):
        data['condition'][i] = data['condition'][i]['text']

    data['loc_name'] = response3_c1['location']['name'] + ", " + response3_c1['location']['region'] + ", " + response3_c1['location']['country']
    data['loc_lat'] = response3_c1['location']['lat']
    data['loc_long'] = response3_c1['location']['lon']
    req_cols = ['loc_name','loc_lat','loc_long','time','temp_c','humidity','condition']
    city1 = data[req_cols]
    return city1

city = ['Toronto', 'Pickering', 'Ottawa', 'Brampton', 'Oshawa']
fore_weather_data = pd.DataFrame()
dist_data = fore_weather(city[0])
dist_data1 = pd.DataFrame(dist_data)
dist_data = fore_weather(city[1])
dist_data2 = pd.DataFrame(dist_data)
dist_data = fore_weather(city[2])
dist_data3 = pd.DataFrame(dist_data)
dist_data = fore_weather(city[3])
dist_data4 = pd.DataFrame(dist_data)
dist_data = fore_weather(city[4])
dist_data5 = pd.DataFrame(dist_data)
dist_data = [dist_data1, dist_data2, dist_data3, dist_data4, dist_data5]
fore_weather_data = pd.concat(dist_data, ignore_index=True)

fore_weather_data

#Make changes to DB credentials to be able to access your own Database
db_secret = {
    "drivername" : "postgresql+psycopg2",
    "host" : "mmai5100postgres.canadacentral.cloudapp.azure.com",
    "port" : 5432,
    "database" : "kaiarish",
    "user" : "kaiarish",
    "password" : "2022!Schulich"
}

def create_db_engine(**args):

    connection_url = sa.engine.URL.create(
        drivername = args.pop("drivername"),
        username   = args.pop("user"),
        password   = args.pop("password"),
        host       = args.pop("host"),
        port       = args.pop("port"),
        database   = args.pop("database") if 'database' in args else ''
    )

    engine = sa.create_engine(connection_url, **args)

    return engine

engine = create_db_engine(**db_secret)

connection = engine.connect()
connection.execute("CREATE SCHEMA IF NOT EXISTS uploads;")
connection.close()

tot_dist_data.to_sql(
    name = 'total_distance_data',
    con = engine,
    schema = 'uploads',
    if_exists = 'replace' ,
    index = False ,
    dtype = {
        'org_loc' : types.VARCHAR(255),
        'dest_loc' : types.VARCHAR(255),
        'dist_km' : types.FLOAT,
        'dist_m' : types.VARCHAR(255),
        'dur' : types.VARCHAR(255),
        },
    method = 'multi',
)

hist_weather_data.to_sql(
    name = 'hist_weather_data',
    con = engine,
    schema = 'uploads',
    if_exists = 'replace' ,
    index = False ,
    dtype = {
        'loc_name' : types.VARCHAR(255),
        'loc_lat' : types.FLOAT,
        'loc_long' : types.FLOAT,
        'time' : types.DateTime,
        'temp_c' : types.FLOAT,
        'humidity' : types.FLOAT,
        'cond' : types.VARCHAR(50)
    },
    method = 'multi',
)

fore_weather_data.to_sql(
    name = 'fore_weather_data',
    con = engine,
    schema = 'uploads',
    if_exists = 'replace' ,
    index = False ,
    dtype = {
        'loc_name' : types.VARCHAR(255),
        'loc_lat' : types.FLOAT,
        'loc_long' : types.FLOAT,
        'time' : types.DateTime,
        'temp_c' : types.FLOAT,
        'humidity' : types.FLOAT,
        'cond' : types.VARCHAR(50)
    },
    method = 'multi',
)